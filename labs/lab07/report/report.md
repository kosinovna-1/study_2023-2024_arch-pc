---
## Front matter
title: "РУДН. Архитектура компьютеров"
subtitle: "Отчёт по лабораторной работе №7"
author: "Косинов Никита Андреевич, НПМбв-02-20"

## Generic otions
lang: ru-RU
toc-title: "Содержание"

## Bibliography
bibliography: bib/cite.bib
csl: pandoc/csl/gost-r-7-0-5-2008-numeric.csl

## Pdf output format
toc: true # Table of contents
toc-depth: 2
lof: true # List of figures
lot: true # List of tables
fontsize: 12pt
linestretch: 1.5
papersize: a4
documentclass: scrreprt
## I18n polyglossia
polyglossia-lang:
  name: russian
  options:
	- spelling=modern
	- babelshorthands=true
polyglossia-otherlangs:
  name: english
## I18n babel
babel-lang: russian
babel-otherlangs: english
## Fonts
mainfont: PT Serif
romanfont: PT Serif
sansfont: PT Sans
monofont: PT Mono
mainfontoptions: Ligatures=TeX
romanfontoptions: Ligatures=TeX
sansfontoptions: Ligatures=TeX,Scale=MatchLowercase
monofontoptions: Scale=MatchLowercase,Scale=0.9
## Biblatex
biblatex: true
biblio-style: "gost-numeric"
biblatexoptions:
  - parentracker=true
  - backend=biber
  - hyperref=auto
  - language=auto
  - autolang=other*
  - citestyle=gost-numeric
## Pandoc-crossref LaTeX customization
figureTitle: "Рис."
tableTitle: "Таблица"
listingTitle: "Листинг"
lofTitle: "Список иллюстраций"
lotTitle: "Список таблиц"
lolTitle: "Листинги"
## Misc options
indent: true
header-includes:
  - \usepackage{indentfirst}
  - \usepackage{float} # keep figures where there are in the text
  - \floatplacement{figure}{H} # keep figures where there are in the text
---

# Цель работы

Кроме арифметических операций, нам необходимо выполнять логические. То есть, необходимо уметь сравнивать объекты: строки и числа, и, в зависимости от результата,выполнять то или иное действие. В языке Ассемблер предусмотрены такие переходы: без условия и с условием. Оба перехода происходят, например, с помощью меток, отличие в том, что переход в случае наличия условия происходит только при выполнении этого условия.

Цель данной работы - познакомиться с механикой условных и безусловных переходов языка Ассемблер.

# Ход работы

Лабораторная работа выполнена с использованием консоли **OC Linux** и языка программирования ассемблера **NASM**.

1. Безусловный переход;

2. Условный переход;

3. Файл листинга.

В конце выполнена самостоятельная работа.

# Безусловный переход

В начале работы познакомимся с тем, как в языке Ассемблер работает система меток.

1. Переходим в рабочий каталог и создайм файл формата **\*.asm**.

![Создание файла](./image/1.png){#fig:fig1 width=70%}

2. Напишем программу, использующую метки. Переход в участок программы происходит посредством команды **jmp**, далее код продолжает работать сверху вниз.

![Код программы 7-1](./image/2.png){#fig:fig1 width=70%}

3. Скомпилируем и запустим.

![Исполняемый файл 7-1](./image/3.png){#fig:fig1 width=70%}

4. Мы видим, что из-за перехода на метку **_label2** в самом начале кода программа пропустила всё, написанное до этой метки, а именно вывод "Сообщение №1".

5. Изменим код программы, добавив переход из в конце второго блока в первый, а также переход с конца первого блока в финальный.

![Код программы 7-1-1](./image/4.png){#fig:fig1 width=70%}

6. Скомпилируем и запустим.

![Исполняемый файл 7-1-1](./image/5.png){#fig:fig1 width=70%}

7. Как и ожидалось, сначала произошёл вывод 2-го сообщения, затем 1-го и выход из порграммы.

8. Изменим первый переход, поменяв 2-ю на 3-ю метку, а в третий блок программы добавим переход ко второй метке так, чтобы сообщения выводились в обратном порядке.

![Код программы 7-1-2](./image/7.png){#fig:fig1 width=70%}

9. Проверим результат

![Исполняемый файл 7-1-2](./image/6.png){#fig:fig1 width=70%}
		
# Условный переход

Условный переход - это переход между частями кода, если выполнено некоторое условие. Инструкций по передаче управления по метке много, но все начинаются с буквы **j**, так как работают по принципу **jmp**, только с условием.

1. Напишем программу, определяющую максимум из трёх элементов. Две переменные зададим в самом коде, а третью попросим ввести с клавиатуры пользователя.

![Часть кода программы 7-2](./image/8.png){#fig:fig1 width=70%}

2. Разберём код:

	3.1. Первыми двумя блоками выведем приглашение ввести третье число и считаем его с клавиатуры.
	
	3.2. Преобразуем его в число функцией **atoi** подключенного файла.
	
	3.3. Запишем значение первой переменной в созданный буфер *max*.
	
	3.4. Сравним переменные *A* и *С* инструкцией **cmp**, но как символы. Так можно сделать, т.к. числа в десятичной записи сравниваются в лексикографическом порядке, и коды цифры в кодировке **ASCII** идут по возрастанию самих цифр.
	
	3.5. Результат сравнения переменных запишется в регистр флагов. Инструкция **jg** сработает в случае, если *A>C* и позволяет сразу перейти к сравнению *max=A* и *В*. В противном случае, поменяем значение *max* на *C*, и уже после перейдём к сравнению *max=C* и *В*.
	
	3.6. Находим максимум окончательно и выводим результат на экран.

3. Скомпилируем и запустим программу. Попробуем её в работе для разных значений третьей переменной. Убеждаемся, что программа работает корректно!

![Исполняемый файл 7-2](./image/9.png){#fig:fig1 width=70%}

# Файл листинга

Файл листинга - документ, использующийся при отладке кода программы. Он содержит код на написанном языке, а также машинный код.

1. Создадим файл листинга предыдущей программы, указав ключ **-l** при создании объектного файла.

![Создание файла листинга](./image/10.png){#fig:fig1 width=70%}

2. Рассмотрим структура созданного документа.

![Фрагмент файла листинга](./image/11.png){#fig:fig1 width=70%}

![Фрагмент файла листинга](./image/12.png){#fig:fig1 width=70%}

3. Проследим за структурой листинга:

	3.1. Номера строк исходной программы, причём в случае нескольких команд машинного кода по одной строке написанного нами, этот номер несколько раз дублируется.
	
	3.2. Адрес, на сколько мы сместились от начала сегмента.
	
	3.3. Машинный код каждой инструкции в шеснадцатиричной системе счисления.
	
	3.4. Исходный код программы и написанные в нём комментарии.
	
4. Изменим код, убрав из команды **mov** второй операнд.

![Изменения кода 7-2](./image/13.png){#fig:fig1 width=70%}

5. Попробуем создать файл листинга. Но у нас это не выйдет, так как в программе допущена ошибка *неправильное использование инструкции и операндов*. Соответственно, компиляция прерывается, и фапйл листинга не создаётся. Таким образом, последний нужен именно для отладки работающей программы, но не для поиска допущенных синтаксических ошибок.

![Ошибка!](./image/14.png){#fig:fig1 width=70%}

# Самостоятельная работа

Текущая самостоятельная работа состоит из двух задач **I** варианта.

1. В первой задаче требуется найти минимум значений трёх чисел: *a=17, b=23, c=45*. Напишем программу, добавив комментарии.

![Фрагмент кода программы sr-1](./image/24.png){#fig:fig1 width=70%}
![Фрагмент кода программы sr-1](./image/25.png){#fig:fig1 width=70%}

2. Скомпилируем и запустим.

![Исполняемый файл sr-1](./image/23.png){#fig:fig1 width=70%}

3. Во второй задаче требуется вычислить значение функции с условием, в зависимости от введённых с клавиатуры чисел и . Результатом должно быть число, равное , если  и число, если . Напишем код программы, добавив комментарии.

![Код программы sr-2](./image/20.png){#fig:fig1 width=70%}

![Код программы sr-2](./image/21.png){#fig:fig1 width=70%}

4. Скомпилируем и запустим. Проверим работу программы на занчениях из варианта и пары собственных

![Исполняемый файл sr-2](./image/17.png){#fig:fig1 width=70%}

# Выводы

В ходе данной лабораторной работы мы научились пользоваться переходами между частями кода с условием и без, а также познакомились со структурой отладочного документа - файла листинга.


::: {#refs}
:::
